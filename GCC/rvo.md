# 返回值优化

## 函数返回值在编译器中的实现机制

函数返回值的传递分为两种情况：

- 当返回的对象不超过 8 字节时，通过寄存器（eax edx）返回

- 当返回的对象大于 8 字节时，通过栈返回。此处需要注意的时候，如果返回的是 `struct` 或者 `class` 对象，即使其大小不大于 8 字节，也是通过栈返回的

在通过栈返回的时候，栈上会有一块空间来保存函数的返回值；当函数结束的时候，会把要返回的对象拷贝到这块区域，对于内置类型是直接拷贝，类类型的话是调用拷贝构造函数；这块区域又称为函数返回的临时对象

## 编译器优化

编译器省略返回类对象时的复制和移动构造，即使复制/移动构造函数和析构函数拥有可观察副作用，而直接将对象构造到它们本来要复制/移动到的存储中

```cpp
class Obj {
 public:
  Obj() { // 构造函数
    std::cout << "in Obj() " << " " << this << std::endl;
  }
  
  Obj(int n) {
    std::cout << "in Obj(int) " << " " << this << std::endl;
  }

  Obj(const Obj &obj) { // 拷贝构造函数
    std::cout << "in Obj(const Obj &obj) " << &obj << " " << this << std::endl;
  }

  Obj &operator=(const Obj &obj) { // 赋值构造函数

    std::cout << "in operator=(const Obj &obj)" << std::endl;
    return *this;
  }

  ~Obj() { // 析构函数
    std::cout << "in ~Obj() " << this << std::endl;
  }

int n;
};

Obj fun() {
  Obj obj;
  // do sth;
  return obj;
}

int main() {
  Obj obj = fun();
  std::cout << "&obj is " << &obj << std::endl;
  return 0;
}
```

### 禁止优化

编译器提供了个编译选项 `-fno-elide-constructors` 来禁用返回值优化

禁止编译器优化时，调用 `Obj` 类成员函数的顺序应该为：

- 调用构造函数，生成对象

- 调用拷贝构造函数，生成临时对象

- 析构第 1 步生成的对象

- 调用拷贝构造函数，将第 2 步生成的临时变量拷贝到 `main()` 函数中的局部对象 `obj` 中

- 调用析构函数，释放第 2 步生成的临时对象

- 调用析构函数，释放 `main()` 函数中的 `obj` 局部对象

## RVO

```cpp
int main() {
  Obj obj = fun();  // obj 未具名
  return 0;
}
```

当一个未具名且未绑定到任何引用的临时变量被移动或复制到一个相同的对象时，拷贝和移动构造可以被省略

当这个临时对象在被构造的时候，它会直接被构造在将要拷贝/移动到的对象

当未命名临时对象是函数返回值时，发生的省略拷贝的行为被称为 RVO

通过 RVO，编译器可以减少函数返回时生成临时对象的个数，从某种程度上可以提高程序的运行效率，对需要分配大量内存的类对象其值复制过程十分友好

RVO 优化针对的是返回一个未具名对象，也就是说 RVO 的功能是消除函数返回时创建的临时对象

编译器明确知道函数会返回哪一个局部对象，那么编译器会把存储这个局部对象的地址和存储返回临时对象的地址进行复用，也就是说避免了从局部对象到临时对象的拷贝操作，这就是 RVO

## NRVO

```cpp
int main() {
  Obj obj;
  obj = fun();  // obj 具名
  return 0;
}
```

NRVO 为 RVO 的一个变种，也是一种编译器对于函数返回值优化的方式

NRVO 与 RVO 的区别是返回的对象是具名的，既然返回的对象是具名的，那么对象是在 `return` 语句之前就构造完成

## 原理

返回值优化的原理是将返回一个类对象的函数的返回值当做该函数的参数来处理

### RVO 原理

RVO 优化的原理是消除函数返回时产生的一次临时对象

编译器会将返回值函数的原型进行调整，编译器启用 RVO 优化，`fun()` 函数会变成

```cpp
void fun(Obj &_obj) {
  Obj obj(1);
  _obj.Obj::Obj(obj); // 拷贝构造函数
  return;
}

int main() {
  Obj obj; // 仅定义不构造
  fun(obj);
  return 0;
}
```

经过上述转换，编译器将只调用一次构造函数和一次拷贝构造函数

### NRVO 原理

经过 NRVO 优化，去掉了 RVO 优化遗留的拷贝构造问题，达到了优化目标

```cpp
void fun(Obj &_obj) {
   _obj.Obj::Obj(1);
}

int main() {
  Obj obj;
  fun(obj);
  
  return 0;
}
```

## 经验

代码优化不应该依赖编译器，因为无法保证在其他编译器下就能得出跟当前类似的优化效果

- 对于 `char`、`int`、`double` 等类型，在函数中直接返回

- 对于需要返回 `struct`、`class` 类型的函数，则直接作为函数入参，在函数内部进行初始化
