# 类继承

## 构造、析构

派生类构造函数必须使用基类的构造函数

创建派生类对象时，程序先创建基类对象，意味着基类对象应当在程序进入派生类构造函数之前被创建，可以使用初始化列表完成这一工作

如果不调用基类构造函数，程序将使用默认的基类构造函数，所以除非要使用默认构造函数，否则应显示调用正确的基类构造函数

释放对象顺序与创建顺序相反，即先释放派生类析构函数，再自动调用基类的析构函数

## 访问权限

- `public`：派生类和外部都可以直接访问

- `protected`：派生类中可以直接访问，外部不能直接访问

- `private`：派生类和对象都不能直接访问

## 公有派生

```cpp
class derivedClass : public baseClass {
};
```

- 基类 `public` 成员继承后还是 `public`

- 基类 `protected` 成员继承后还是 `protected`

- 基类 `private` 成员继承后还是 `private``

## 保护继承

```cpp
class derivedClass : protected baseClass {
};
```

- 基类 `public` 成员继承后是 `protected`

- 基类 `protected` 成员继承后还是 `protected`

- 基类 `private` 成员继承后还是 `private``

## 私有继承

使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，意味着基类方法不会成为派生类对象公有接口的一部分，但可以在派生类的成员函数中使用

- 基类 `public` 成员继承后是 `private`

- 基类 `protected` 成员继承后是 `private`

- 基类 `private` 成员继承后还是 `private``

## 抽象基类

使用纯虚函数提供未实现的函数，`virtual type Func(int , double b) const = 0`

当类声明中包含纯虚函数时，则不能创建类的对象，只能用作基类，即抽象基类

派生类必须覆盖纯虚函数

## 多态公有继承

```cpp
class baseClass
{
public:
    baseClass(){};
    virtual void func();
};

class derivedClass : public baseClass
{
public:
    derivedClass(){};
    virtual void func();
};
```

同一个方法在派生类和基类中的行为不同，成为多态

实现多态的两种机制：在派生类中重新定义基类的方法；使用 `virtual` 虚方法；使用指针或引用调用成员函数：

- 如果没有 `virtual` 关键字，程序将根据引用类型或指针类型选择方法

- 如果有 `virtual` 关键字，程序将根据引用或指针指向的对象的类型来选择方法（基类指针或引用可以指向派生类）

经常在基类中将派生类会重新定义的方法声明为虚方法；方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法，但最好也使用 `virtual` 关键字

基类声明一个虚析构函数，确保释放派生对象时，按正确的顺序调用析构函数；构造函数不能是虚函数；友元不能是虚函数，因为友元不是类成员，只有类成员才能使虚函数

重新定义继承的方法并不是重载，重新定义并不会生成函数的两个重载版本，无论参数列表是否相同，该操作将隐藏所有的同名基类方法